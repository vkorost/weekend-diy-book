# Appendix C: Troubleshooting

Organized by symptom. No prose. Scan for your problem.

---

## Bash Environment Variables Not Persisting

**Symptom:** Environment variables set in one bash command are not available in subsequent commands. Scripts that depend on `export` fail silently.

**Cause:** Each bash command runs in a fresh shell environment. Working directory persists; everything else (variables, aliases, shell functions) does not.

**Fix:**
- Chain dependent commands in a single bash call using `&&`
- Write variables to a file and source it: `echo "export FOO=bar" > .env && source .env && echo $FOO`
- Use CLAUDE.md to document required environment variables so Claude sets them in each command

---

## Context Exhaustion (Claude Forgets Instructions)

**Symptom:** Claude stops following CLAUDE.md rules, produces inconsistent output, drops tasks from a multi-step plan, or "forgets" decisions made earlier in the conversation.

**Cause:** Context window is full or near-full. Auto-compaction has summarized earlier conversation, losing detail. Instructions not in CLAUDE.md are not preserved through compaction.

**Fix:**
- Move critical rules to the "Compact Instructions" section of CLAUDE.md (survives compaction)
- Reduce always-on context costs: trim CLAUDE.md, remove unused MCP servers, convert reference material to skills
- Start a new session for new tasks instead of continuing indefinitely
- Use `/compact` manually before critical operations to reclaim space with controlled summarization
- Delegate verbose operations to subagents (isolated context windows)

---

## Auto-Compaction Triggering Too Late (or Too Early)

**Symptom:** Session degrades before compaction kicks in, or compaction triggers when you still have space to work.

**Cause:** Default compaction threshold is ~95% of context capacity.

**Fix:**
- Set `CLAUDE_AUTOCOMPACT_PCT_OVERRIDE` environment variable
- Lower value (e.g., `80`) = earlier compaction, more headroom, less detail preserved
- Higher value (e.g., `98`) = later compaction, more detail, risk of degradation before trigger

---

## `claude doctor` Diagnostics

**Symptom:** Claude Code behaves unexpectedly, fails to start, or connections fail.

**Run:** `claude doctor`

**What it checks:**
- Authentication status and token validity
- Network connectivity to API endpoints
- Configuration file syntax errors
- MCP server availability
- Environment variable conflicts
- Binary version and update status

**When to use:** First step for any issue that is not obviously a context or prompt problem.

---

## Claude Repeats the Same Error

**Symptom:** Claude makes the same mistake across sessions -- wrong import path, incorrect test command, deprecated API usage, wrong module reference.

**Cause:** The error pattern is not captured in persistent context. Each session starts fresh without knowledge of previous failures.

**Fix:**
- Add a targeted instruction to CLAUDE.md addressing the specific error
- Example: `"Always import from @app/db/utils, never @app/utils/db (deprecated path)"`
- Be specific: describe the wrong behavior AND the correct behavior
- Place in project-level CLAUDE.md so all team members benefit

---

## Checkpoint Restore Does Not Undo Changes

**Symptom:** `Esc-Esc` rewind does not restore expected file state. Files modified by bash commands (`rm`, `mv`, `cp`, `sed`) are not reverted.

**Cause:** Checkpoints only track file edits made through Claude Code's Write/Edit tools. Changes made via bash commands, external editors, or other concurrent sessions are not tracked.

**Fix:**
- Use git for full recovery: `git checkout -- <file>` or `git stash`
- Commit frequently before risky operations
- Prefer Claude Code's built-in file tools over bash for file modifications when possible
- For destructive operations, ask Claude to create a backup first

---

## Deciding: Restart Fresh vs. Correct Mid-Stream

**Symptom:** Claude is going in the wrong direction, producing incorrect code, or following a bad plan. Unclear whether to redirect or start over.

**When to restart fresh:**
- Claude has filled context with incorrect exploration
- The fundamental approach is wrong, not just the details
- Multiple correction attempts have not converged
- Context is near compaction threshold

**When to correct mid-stream:**
- The approach is correct but details are wrong
- You can describe the fix concisely
- Context has plenty of remaining capacity
- Claude has built up useful understanding that would be lost

**Pattern:** Commit current state to git before deciding. If you restart, the commit preserves any useful fragments. If you correct, the commit gives you a rollback point.

---

## WebSocket Scaling Limitations

**Symptom:** Real-time features generated by Claude Code (chat interfaces, live dashboards, streaming feeds) fail under load or drop connections.

**Cause:** Claude Code generates correct WebSocket scaffolding but does not automatically handle production-scale concerns: connection pooling, backpressure, reconnection logic, heartbeat keepalives.

**Scaling thresholds:**

| Concurrency | Recommended Stack |
|-------------|-------------------|
| MVP (<50 concurrent) | Python + FastAPI is sufficient |
| Scaling (>100 concurrent) | Go or Node.js required; Python struggles at this level |
| High scale (1000+) | Go strongly preferred |

**Fix:**
- Explicitly request connection pooling and reconnection logic in prompts
- Add load-testing requirements to acceptance criteria
- Manually review generated WebSocket code for: max connection limits, heartbeat intervals, graceful degradation, memory leaks from unclosed connections
- Review backpressure handling: Claude can scaffold it, but verify against your latency SLA
- Consider using a dedicated real-time messaging library rather than raw WebSocket handling

---

## FIX Protocol Limitations

**Symptom:** Generated FIX protocol message builders compile but produce incorrect or incomplete messages, or fail conformance testing.

**Cause:** FIX protocol is highly complex with domain-specific semantics. Claude Code can generate FIX message builders but lacks the deep domain knowledge required for production-grade implementations.

**Fix:**
- Treat Claude-generated FIX code as scaffolding only
- Have a FIX domain expert review all generated message builders
- Test against a FIX conformance test suite before production use
- Use Claude Code for wrapping standard REST/WebSocket broker APIs instead when possible

---

## MCP Server Disconnection Recovery

**Symptom:** MCP tools stop working mid-session. Tool calls fail silently or return errors. No warning that the server disconnected.

**Cause:** MCP server connections can drop without notification. Tools disappear from Claude's available tool set.

**Fix:**
- Run `/mcp` to check server status and token costs
- Restart the MCP server if it crashed (check its process/logs)
- Start a new Claude Code session to re-establish connections
- For persistent issues, check MCP server logs for timeout or memory errors
- Add health-check logic to custom MCP servers
- Consider PreToolUse hooks that verify MCP availability before critical operations

---

## Session Lost After Crash or Terminal Close

**Symptom:** Work from a previous session is gone. Claude does not remember what it was doing.

**Cause:** Each session is independent. Context exists only within a session. Closing the terminal or crashing loses unsaved context.

**Fix:**
- Resume the previous session: `claude -c` (continue most recent) or `claude -r <session-id>`
- Use `claude --resume` to browse and select from recent sessions
- For critical multi-session work, persist state in files: specs, task lists (.claude/tasks/), CLAUDE.md updates
- Name important sessions with `/rename` for easier recovery

---

## Subagent Results Consuming Too Much Main Context

**Symptom:** After running multiple subagents, the main conversation's context fills rapidly. Compaction triggers unexpectedly.

**Cause:** Each subagent returns its results to the main context. Multiple subagents with detailed outputs consume main context quickly.

**Fix:**
- Instruct subagents to return concise summaries, not full details
- Reduce the number of concurrent subagents
- Write subagent results to files instead of returning them in conversation
- Run `/compact` after processing subagent results you no longer need in active context

---

## Claude Produces Over-Complex Solutions

**Symptom:** Claude generates elaborate abstractions, unnecessary design patterns, or complex architectures for simple problems.

**Cause:** Default behavior tends toward comprehensive solutions. Without constraints, Claude adds flexibility, extensibility, and abstraction layers.

**Fix:**
- Add to CLAUDE.md: `"Prefer the simplest solution that meets requirements. No unnecessary abstractions."`
- Be explicit about scope: `"This is a one-off script, not a library"`
- Specify constraints: `"No new dependencies"`, `"Single file"`, `"Under 100 lines"`
- Request Claude to justify complexity when it appears
- Interrupt mid-execution and ask "why are you doing this? Try something simpler"

---

## Verifying Proxy or Gateway Configuration

**Symptom:** API calls fail, authentication errors, or unexpected model routing when using a corporate proxy or LLM gateway.

**Cause:** Proxy URL, base URL, or authentication headers are misconfigured or conflicting.

**Fix:**
- Run `/status` to verify current proxy and gateway configuration
- Check `ANTHROPIC_BASE_URL`, `HTTP_PROXY`, and `HTTPS_PROXY` environment variables
- Ensure proxy certificates are trusted by the system
- For LLM gateways handling authentication, set the appropriate skip-auth variable (`CLAUDE_CODE_SKIP_BEDROCK_AUTH=1` or `CLAUDE_CODE_SKIP_VERTEX_AUTH=1`)

---

## Debugging with Verbose Output

**Symptom:** Unclear why Claude made a decision, why a tool call failed, or what data hooks received.

**Cause:** Default output suppresses detailed tool usage, hook execution, and internal processing information.

**Fix:**
- Press `Ctrl+O` to toggle verbose output, showing detailed tool usage and execution
- Run `claude --debug` to see hook execution details including which hooks matched, exit codes, and output
- Check hook stderr output (visible in verbose mode for non-blocking errors)
- For hooks specifically, verify JSON parsing by examining raw stdout with `Ctrl+O` enabled

---

## Hook Not Firing

**Symptom:** A configured hook does not execute when expected. No output, no error.

**Cause:** Common causes include non-executable scripts, matcher not matching the tool name, or hooks modified after session startup without review.

**Fix:**
- Ensure the script is executable: `chmod +x script.sh`
- Verify the shebang line: first line should be `#!/bin/bash` or `#!/usr/bin/env bash`
- Check the matcher matches the exact tool name (e.g., `Bash`, not `bash`)
- If hooks were modified during the session, review changes in the `/hooks` menu
- Check if `disableAllHooks` is set to `true` in settings
- Use `claude --debug` to see which hooks are evaluated and matched

---

## Hook JSON Parsing Errors

**Symptom:** Hook returns exit code 0 but JSON output is not processed. Claude ignores the hook's decision.

**Cause:** Non-JSON text in stdout (often from shell profile scripts) interferes with JSON parsing.

**Fix:**
- Ensure stdout contains only the JSON object on exit 0
- Redirect any non-essential output to stderr: `echo "debug info" >&2`
- Check if shell profile (`.bashrc`, `.zshrc`) prints text on startup that pollutes stdout
- Test the script manually and inspect raw output
